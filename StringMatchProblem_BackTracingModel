package Algorithms.BackTracing;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * 1 last time we do this the implementation is so complex to control it
 * and we do some analysis
 * 1 the construction of model ability is poor so we review the knight tour and the queen problem to find
 * the best way to handle the model we need to use a increment way to let the xi get the value and we do the
 * choice in the list of the range of the xi so that is a good way !
 * 2 use the easy data structure .
 * 2 so this time we are back .
 * so how to model the problem ?
 * 1 what is the solution variable and set ? why you want to use the backtrace ? we want to record the detail of the
 * matching process for some condition . if two string matches here are different combination and we really want to
 * see it ! that is really terrific
 * let we think yes
 * with the constraint we can find for a given pattern its solution set is fixed !
 * for example .*ac*.  the index 0 corresponds to .* ,1 represents a ,2 represents c* and 3 represents .
 * that is all about that and we can use simple data structure just string array to do this record . so how to do that
 * we can use the string to its char array and traverse it . in this process every time we find a xi. yes that is the
 * char[] we transfer it into string and put it into the string[]
 * 2 and with the big picture . every time we can find the you know the range of the xi with the constraint what happen?
 * the substring changed ! yes and so with the different substring transfer to the next layer ! so
 * the substring will influence the next you know range of the xi+1; that is the point !
 * so that is ok too ! so we can compute what the range of the current layer and do the selection
 * and we can also transfer the corresponding substring to next layer so how to implement it ?
 * yes after we put the you know . the xi into the string[] we can use the substring to do the divide .because from the
 * set view . range + substring  = current string . so we can use one method to produce this two . and the best way is
 * use the substring() method . for one 0 to i for the other one i ! yes .
 * 3 ok now we need to think how to return and the base condition to end the recursion !
 * if xi where i = n ; the range is nothing ! even no " " end return to the previous layer . do the repeal modification
 * movement .
 * that is it !
 * if xi where i = length -1 the range have somethings but with different type
 * if l-1 is "a"  so if we want happy ending the range must be "a"  ! return and display and how to display ?
 * no that is not good . yes when xi went to the next stage it means the previous stage ok . that is what we
 * design . but ! when display .? we need both to the end ! so we need add more check ! so the range is a .and substring
 * without a = empty , length == 0 ! ---- with a and substring = a ;
 * we can add a record string[] with the same length of the solution string[] that is great !
 * if l-1 = "." . can be any char or " "but the display need to both to the end and we don't want the array index overload
 * so ? when l-1 . if substring length == 1 . that is ok contains " " that is ok too !
 * and we will record "EMPTY" for the record if the substring == " "!
 * and ok with this thought . let we think ! if
 * C* in the l-1 and what is the end of the target substring .ok substring length == 0 is ok or substring .length is
 * not empty but will all the C .
 * so with same idea if l-1
 * is ".*" substring length == 0 is ok or substring.length is not 0
 * but we record different things ! in such way we do the right display ! wow that is many branches !
 * so what is the false cases?
 * that depends what stages ?
 * ok not to the end !
 * for "a" the available range list = 0 return;
 * "." the available range list = 0  return; but this is some special at least 1 ok ?
 * "c*" the available range list = 0  return; but this is some special at least 1 ok ?
 * ".*" the available range list = 0  return; but this is some special at least 1 ok ?
 * just at the end of the loop for the selection !
 * to the end
 * if in the end despite the display case  all other case is abandoned ! with a return ;
 *
 * oh my god yes the thoughts are just very great but in the implementation . the string handling just kill me
 * and kick me ass ! that is too many detail to handle and the code become inevitable complex too much if and else
 * and yes too much too much empty handle ! that is just disaster ! so that is just a big problem
 * and maybe we should to learn how to trace the you know the matching or in the DP we want to know
 * we want to know the . the array index exceed and so on problems .
 * so we want to use the DP to get the result and use the trace method to record the match ! ?
 */
public class StringMatchProblem_BackTracingModel {
    public static void main(String[] args) {
        String pattern = ".*.*a";
        String target = "ccccccccbbbbbbba";

        HashMap<String, String[]> resultMap = getSolutionSetAndRecordArray(pattern);
        String[] record = resultMap.get("record");
        String[] solutionSet = resultMap.get("solutionSet");

        displayInfo(target, solutionSet);
        searchAvailableMatch(solutionSet, record, target, 0);
    }

    private static void displayInfo(String target, String[] solutionSet) {
        System.out.println("target : " + target);
        System.out.print("solutionSet ï¼š ");
        for (int i = 0; i < solutionSet.length; i++) {
            System.out.printf("%-5s", solutionSet[i]);
        }
        System.out.println();
    }

    public static void searchAvailableMatch(String[] solutionSet, String[] record, String target, int order) {
        if (judge(solutionSet, record, target, order)) return;

        HashMap<String, List<String>> resultMap = getRangeOfXiAndSubString(solutionSet, target, order);
        List<String> availableRange = resultMap.get("availableRange");
        List<String> subStringForNextLayer = resultMap.get("subStringForNextLayer");
        for (int i = 0; i < availableRange.size(); i++) {
            record[order] = availableRange.get(i);
            order = order + 1;
            searchAvailableMatch(solutionSet, record, subStringForNextLayer.get(i), order);
            order = order - 1;
            record[order] = "NULL";
        }
        return;
    }

    private static boolean judge(String[] solutionSet, String[] record, String target, int order) {
        if (order > solutionSet.length - 1) {
            return true;
        }
        if (order != solutionSet.length - 1 && target == "EMPTY") {
            return true;
        }
        if (order == solutionSet.length - 1) {
            String Xi = solutionSet[order];
            char[] xi = Xi.toCharArray();
            if (xi[0] == '.' && Xi.length() == 1) {
                if (target.length() == 1 || target == "EMPTY") {
                    displayResult(record, target, order);
                    return true;
                }
            }
            if (xi[0] == '.' && Xi.length() == 2) {
                displayResult(record, target, order);
                return true;
            }
            if (Xi.length() == 1) {
                char[] elementArray = Xi.substring(0, 1).toCharArray();
                char singleChar = elementArray[0];
                char[] targetArray = target.toCharArray();
                if (targetArray.length == 1 && targetArray[0] == singleChar) {
                    displayResult(record, target, order);
                } else {
                    return true;
                }
            }
            if (Xi.length() == 2) {
                if (target == "EMPTY") {
                    displayResult(record, target, order);
                    return true;
                }
                char[] elementArray = Xi.substring(0, 1).toCharArray();
                char singleChar = elementArray[0];
                char[] targetArray = target.toCharArray();
                for (int j = 0; j < targetArray.length; j++) {
                    if (targetArray[j] != singleChar) {
                        return true;
                    }
                }
                displayResult(record, target, order);
                return true;
            }
        }
        return false;
    }

    private static void displayResult(String[] record, String target, int order) {
        record[order] = target;
        System.out.printf("one valid result : ");
        for (int i = 0; i < record.length; i++) {
            System.out.printf("%-15s", record[i]);
        }
        System.out.println();
    }

    public static HashMap<String, List<String>> getRangeOfXiAndSubString(String[] solutionSet, String target, int order) {
        List<String> availableRange = new ArrayList<>();
        List<String> subStringForNextLayer = new ArrayList<>();
        String Xi = solutionSet[order];
        char[] xi = Xi.toCharArray();

        if (Xi.length() == 1) {
            if (xi[0] == '.') {
                availableRange.add(target.substring(0, 1));
                availableRange.add("EMPTY");
                subStringForNextLayer.add(target.substring(1));
                subStringForNextLayer.add(target);
            } else {
                char[] elementArray = Xi.substring(0, 1).toCharArray();
                char singleChar = elementArray[0];
                char[] targetArray = target.toCharArray();
                if (targetArray.length > 0 && targetArray[0] == singleChar) {
                    availableRange.add(Xi.substring(0, 1));
                    subStringForNextLayer.add(target.substring(1));
                }
            }
        }

        if (Xi.length() == 2) {
            if (xi[0] == '.') {
                availableRange.add("EMPTY");
                for (int i = 0; i < target.length(); i++) {
                    availableRange.add(target.substring(0, i + 1));
                    subStringForNextLayer.add(target.substring(i));
                }
                subStringForNextLayer.add("EMPTY");
            } else {
                char[] elementArray = Xi.substring(0, 1).toCharArray();
                char singleChar = elementArray[0];
                char[] targetArray = target.toCharArray();
                int num = 0;
                while (num < targetArray.length && targetArray[num] == singleChar) {
                    num++;
                }
                String subString = target.substring(0, num);
                availableRange.add("EMPTY");
                for (int k = 1; k <= num; k++) {
                    availableRange.add(subString.substring(0, k));
                    subStringForNextLayer.add(target.substring(k - 1));
                }
                subStringForNextLayer.add("EMPTY");
            }
        }

        HashMap<String, List<String>> resultMap = new HashMap<>();
        resultMap.put("availableRange", availableRange);
        resultMap.put("subStringForNextLayer", subStringForNextLayer);
        return resultMap;
    }

    public static HashMap<String, String[]> getSolutionSetAndRecordArray(String pattern) {
        char[] patternArray = pattern.toCharArray();
        int lengthOfSet = 0;
        int i = 0;
        while (i < pattern.length()) {
            if (i + 1 < pattern.length() && patternArray[i + 1] == '*') {
                lengthOfSet++;
                i = i + 2;
            } else {
                lengthOfSet++;
                i = i + 1;
            }
        }
        String[] record = new String[lengthOfSet];
        String[] solutionSet = new String[lengthOfSet];
        int j = 0;
        int length = 0;
        while (j < pattern.length()) {
            if (j + 1 < pattern.length() && patternArray[j + 1] == '*') {
                solutionSet[length] = pattern.substring(j, j + 2);
                length++;
                j = j + 2;
            } else {
                solutionSet[length] = pattern.substring(j, j + 1);
                length++;
                j = j + 1;
            }
        }
        for (int k = 0; k < lengthOfSet; k++) {
            record[k] = "NULL";
        }
        HashMap<String, String[]> resultMap = new HashMap<>();
        resultMap.put("solutionSet", solutionSet);
        resultMap.put("record", record);
        return resultMap;
    }

}
